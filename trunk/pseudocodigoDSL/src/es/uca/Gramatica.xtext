// automatically generated by Xtext
grammar org.xtext.example.mydsl.MyDsl with org.eclipse.xtext.common.Terminals

import "http://diagramapseudocodigo/1.0" 
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

Codigo returns Codigo:
	'Algoritmo' EString
	(comentarios+=Comentario (comentarios+=Comentario)* )?
	('const'
		( constantes+=Constantes (constantes+=Constantes)* )? )?
	('tipo'
		( tipocomplejo+=TipoComplejo (tipocomplejo+=TipoComplejo)* )? )?
	('var'
		( global+=Declaracion ( global+=Declaracion)* )? )?
	(funcion+=Subproceso (funcion+=Subproceso)* )?
	tiene=Inicio
	'fin_algoritmo';

Comentario returns Comentario:
	'//'mensaje= COMENT;
	
TipoComplejo returns TipoComplejo:
	Vector | Matriz | Registro | Archivo | Enumerado | Subrango;


Subproceso returns Subproceso:
	Funcion | Procedimiento;

terminal ML_COMMENT : '/*' (!'*') -> '*/' ;
terminal SL_COMMENT : '//' !('\n'|'\r')* ('\r'? '\n')? ;

Sentencias returns Sentencias:
	LlamadaFuncion | Asignacion | Escribir | Leer | incremento | Bloque | ValorComplejo | FuncionFicheroAbrir | FuncionFicheroCerrar;

Bloque returns Bloque:
	Si | mientras | repetir | desde | segun;

Declaracion returns Declaracion:
	DeclaracionVariable | DeclaracionPropia;

Internas returns Internas:
	nombre=NombreInterna
	'('
		(operador+=Operador ( ',' operador+=Operador)* )
	')';
	
FuncionFicheroAbrir returns FuncionFicheroAbrir:
	'abrir'
	'('
		(variable+=VariableID ',' modo=ModoApertura ',' variable+=Operador)
	')'
;

FuncionFicheroCerrar returns FuncionFicheroCerrar:
	'cerrar'
	'('
		(variable=VariableID)
	')'
;
	
ModoApertura returns ModoApertura:
	'escritura' | 'lectura';


NombreInterna returns NombreInterna:
	'cos' | 'cuadrado' | 'exp' | 'ln' | 'log' | 'sen' | 'sqrt' | 'longitud' | 'concatena';


Operador returns Operador:
	VariableID | ConstCadena | Caracter | NumeroEntero | NumeroDecimal | ValorBooleano | ValorComplejo;

Caracter returns Caracter:
	contenido=CAR;

valor returns valor:
	LlamadaFuncion | VariableID | ConstCadena | NumeroEntero | NumeroDecimal | operacion | ValorBooleano | Caracter | Internas | unaria | ValorComplejo;

valoresLeer returns Operador:
	VariableID | ValorVector | ValorMatriz | ValorRegistro;

ValorComplejo returns ValorComplejo:
	ValorRegistro | ValorVector | ValorMatriz;
	
ValorMatriz returns ValorMatriz:
	((nombre_matriz=EString)'['(indices+=NumeroEntero | indices+=VariableID)']['(indices+=NumeroEntero | indices+=VariableID)']') ('.' (campo+=CampoRegistro) )?;

ValorRegistro returns ValorRegistro:
	nombre_registro=EString '.' (campo+=CampoRegistro ('.' campo+=CampoRegistro)* );
	
ValorVector returns ValorVector:
	((nombre_vector=EString)'['(indice=NumeroEntero | indice=VariableID)']') ('.' (campo+=CampoRegistro) )?;
	
CampoRegistro returns CampoRegistro:
	nombre_campo=EString;

Tipo returns Tipo:
	TipoDefinido | TipoExistente;
	
TipoDefinido returns TipoDefinido:
	tipo=EString;

TipoExistente returns TipoExistente:
	tipo=TipoVariable;

Constantes returns Constantes:
	variable=Variable '=' valor=valor;

Vector returns Vector:
	'vector ' '['(valor=NumeroEntero | valor=VariableID)']' 'de'  tipo=Tipo ': ' nombre=EString;

Matriz returns Matriz:
	'matriz ' '['(valor+=NumeroEntero | valor+=VariableID)']['(valor+=NumeroEntero | valor+=VariableID)']' 'de' tipo=Tipo ': ' nombre=EString;
	

Registro returns Registro:
	'registro:' nombre=EString
			(variable+=Declaracion (variable+=Declaracion)* )
	'fin_registro';
	
Archivo returns Archivo:
	'archivo de ' tipo=Tipo': ' nombre=EString;
	

Enumerado returns Enumerado:
	nombre=EString '=' '{'(valor+=valor (',' valor+=valor )* )'}';
	
Subrango returns Subrango:
	SubrangoNumerico | SubrangoEnumerado;

SubrangoNumerico returns SubrangoNumerico:
	nombre=EString '=' limite_inf=EInt '..' limite_sup=EInt;
	
SubrangoEnumerado returns SubrangoEnumerado:
	nombre=EString "=" limite_inf=EString '..' limite_sup=EString;

Inicio returns Inicio:
	'principal'
	{Inicio}
	'var'
	( declaracion+=Declaracion ( declaracion+=Declaracion)* )?
	'inicio'
		(tiene+=Sentencias (  tiene+=Sentencias)*  )?
	'fin_inicio';

EString returns ecore::EString:
	STRING | ID;

DeclaracionVariable returns DeclaracionVariable:
	tipo=TipoVariable ': '
	variable+=Variable ( ',' variable+=Variable)*;
	
DeclaracionPropia returns DeclaracionPropia:
	tipo=EString ': '
	variable+=Variable (',' variable+=Variable)*;

LlamadaFuncion returns LlamadaFuncion:
	nombre=EString
	'('
		(operador+=valor ( "," operador+=valor)* )?
	')';

Asignacion returns Asignacion:
	 AsignacionNormal | AsignacionCompleja;
	
AsignacionNormal returns AsignacionNormal:
	 lvalue=EString
//	 Mat+=MAT*
	 '='
	operador=valor;

AsignacionCompleja returns AsignacionCompleja:
	complejo=ValorComplejo
//	Mat+=MAT*
	 '='
	operador=valor;

Escribir returns Escribir:
	'escribir'
	'('
		 operador+=Operador ( "," operador+=Operador)* 
	')';

Leer returns Leer:
	'leer'
	'('
		variable=valoresLeer
	')';

Si returns Si:
	'si'valor=valor 'entonces'
		(sentencias+=Sentencias ( sentencias+=Sentencias)* )?
		(devuelve=Devolver)?
	(sino=Sino)?
	'fin_si';

mientras returns mientras:
	'mientras'
	valor=valor 'hacer'
		(sentencias+=Sentencias ( sentencias+=Sentencias)*  )?
	'fin_mientras';

repetir returns repetir:
	'repetir'
		(sentencias+=Sentencias ( sentencias+=Sentencias)*)?
	 'hasta_que' valor=valor;

desde returns desde:
	'desde' asignacion=AsignacionNormal 'hasta' valor=valor 'hacer'
		(sentencias+=Sentencias ( sentencias+=Sentencias)* )?
	'fin_desde';
	
Caso returns Caso:
	operador=Operador ': ' (sentencias+=Sentencias ( sentencias+=Sentencias )* )?
	(devuelve=Devolver)?
;
	
segun returns segun:
	'segun_sea''('valor=valor')''hacer'
		(caso+=Caso ( caso+=Caso )* )?
		'en_otro_caso:'
		(sentencias+=Sentencias ( sentencias+=Sentencias )* )?
		(devuelve=Devolver)?
	'fin_segun';

incremento returns incremento:
	nombre=EString
	ssigno=inc;
	
unaria returns unaria:
	'('
	ssigno=inc
	variable=valor
	')';

TipoVariable returns TipoVariable:
	'entero' | 'caracter' | 'real' | 'logico' | 'cadena';
	
Variable returns Variable:
	 nombre=EString;
//	 Mat+=MAT*;

VariableID returns VariableID:
	nombre=EString;
	//Mat+=MAT*;

terminal CAD: '"' ('a'..'z'|'A'..'Z'|'_'|' '|'!'|'#'|'@'|'%'|'&'|'('|')'|'='|'?'|'\\'|'0'..'9')* '"';
terminal CAR: "'" ('a'..'z'|'A'..'Z'|'_'|' '|'!'|'#'|'@'|'%'|'&'|'('|')'|'='|'?'|'\\'|'0'..'9') "'";
terminal COMENT: '/*' ('a'..'z'|'A'..'Z'|'_'|' '|'!'|'#'|'@'|'%'|'&'|'('|')'|'='|'?'|'\\'|'0'..'9')* '*/';

//terminal MAT: 
//'[' ('a'..'z'|'A'..'Z'|'0'..'9')*('--'|'++')? ']' ;


ConstCadena returns ConstCadena:
	contenido=CAD;

NumeroEntero returns NumeroEntero:
	 valor=EInt;

NumeroDecimal returns NumeroDecimal:
	 valor=EFloat;

ValorBooleano returns ValorBooleano:
	 valor=booleano;

EInt returns ecore::EInt:
	'-'? INT;

EFloat returns ecore::EFloat:
	'-'? INT? '.' INT (('E'|'e') '-'? INT)?;

booleano returns booleano:
	'verdadero' | 'falso'
	;
	
operacion returns operacion:
	'('
		op_izq=operando_izq
		signo_op=signo		
		op_der=operando_der
	')';

signo returns signo:
	('+' | '-' | '*' | '/' | '<' | '>' | '>=' | '<=' | 'y' | 'o' | '==' | '!=')
 /* TODO: implement this rule and an appropriate IValueConverter */;

operando_izq returns operando_izq:
	 oper_izq=valor;

operando_der returns operando_der:
	 oper_der=valor;


Sino returns Sino:
	{Sino}
	'sino'
	(sentencias+=Sentencias ( sentencias+=Sentencias)* )?
	(devuelve=Devolver)?;

Devolver returns Devolver:
	{Devolver}
	'devolver' '(' devuelve=valor ')';

inc returns inc:
	"++" | "--" | "no" /* TODO: implement this rule and an appropriate IValueConverter */;
	
ParametroFuncion returns ParametroFuncion:
	paso=TipoPaso
	tipo=Tipo ": "
	variable=Variable;

Funcion returns Funcion:
	(tipo=TipoVariable)
	'funcion'
	nombre=EString
	'('(parametrofuncion+=ParametroFuncion ( "," parametrofuncion+=ParametroFuncion)*  )?')'
	'const'?
	'tipo'?
	'var'
	( declaracion+=Declaracion ( declaracion+=Declaracion)* )?
	'inicio'
	( sentencias+=Sentencias (  sentencias+=Sentencias)*  )?
	(devuelve=Devolver)?
	'fin_funcion';
	
Procedimiento returns Procedimiento:
	'procedimiento'
	nombre=EString
	'('(parametrofuncion+=ParametroFuncion ( "," parametrofuncion+=ParametroFuncion)*  )?')'
	'const'?
	'tipo'?
	'var'
	( declaracion+=Declaracion ( declaracion+=Declaracion)* )?
	'inicio'
	( sentencias+=Sentencias (  sentencias+=Sentencias)*  )?
	'fin_procedimiento';
	
TipoPaso returns TipoPaso:
	'E' | 'E/S' | 'S'/* TODO: implement this rule and an appropriate IValueConverter */;
