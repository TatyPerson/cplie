/*
 * generated by Xtext
 */
package vary.pseudocodigo.dsl.cpp.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IGenerator
import org.eclipse.xtext.generator.IFileSystemAccess
import javax.inject.Inject
import org.eclipse.xtext.naming.IQualifiedNameProvider
import java.util.Map
import java.util.HashMap
import java.util.ArrayList
import diagramapseudocodigo.Codigo
import diagramapseudocodigo.TipoComplejo
import diagramapseudocodigo.Enumerado
import diagramapseudocodigo.valor
import diagramapseudocodigo.Operador
import diagramapseudocodigo.VariableID
import diagramapseudocodigo.Declaracion
import diagramapseudocodigo.DeclaracionVariable
import diagramapseudocodigo.Variable
import diagramapseudocodigo.DeclaracionPropia
import diagramapseudocodigo.Subproceso
import diagramapseudocodigo.ParametroFuncion
import diagramapseudocodigo.TipoExistente
import diagramapseudocodigo.TipoDefinido
import diagramapseudocodigo.Vector
import diagramapseudocodigo.Matriz
import diagramapseudocodigo.Registro
import diagramapseudocodigo.impl.VectorImpl
import diagramapseudocodigo.impl.MatrizImpl
import diagramapseudocodigo.impl.RegistroImpl
import diagramapseudocodigo.impl.ArchivoImpl
import diagramapseudocodigo.Archivo
import diagramapseudocodigo.impl.EnumeradoImpl
import diagramapseudocodigo.impl.SubrangoNumericoImpl
import diagramapseudocodigo.SubrangoNumerico
import diagramapseudocodigo.SubrangoEnumerado
import diagramapseudocodigo.impl.SubrangoEnumeradoImpl
import diagramapseudocodigo.Tipo
import diagramapseudocodigo.impl.TipoDefinidoImpl
import diagramapseudocodigo.impl.TipoExistenteImpl
import diagramapseudocodigo.Comentario
import diagramapseudocodigo.Constantes
import diagramapseudocodigo.FuncionFicheroAbrir
import diagramapseudocodigo.FuncionFicheroCerrar
import diagramapseudocodigo.Inicio
import diagramapseudocodigo.Sentencias
import diagramapseudocodigo.AsignacionNormal
import diagramapseudocodigo.impl.AsignacionNormalImpl
import diagramapseudocodigo.AsignacionCompleja
import diagramapseudocodigo.impl.AsignacionComplejaImpl
import diagramapseudocodigo.LlamadaFuncion
import diagramapseudocodigo.impl.LlamadaFuncionImpl
import diagramapseudocodigo.impl.SiImpl
import diagramapseudocodigo.Si
import diagramapseudocodigo.segun
import diagramapseudocodigo.Caso
import diagramapseudocodigo.impl.CasoImpl
import diagramapseudocodigo.impl.segunImpl
import diagramapseudocodigo.mientras
import diagramapseudocodigo.impl.mientrasImpl
import diagramapseudocodigo.repetir
import diagramapseudocodigo.impl.repetirImpl
import diagramapseudocodigo.desde
import diagramapseudocodigo.impl.desdeImpl
import diagramapseudocodigo.Negacion
import diagramapseudocodigo.impl.NegacionImpl
import diagramapseudocodigo.Leer
import diagramapseudocodigo.impl.LeerImpl
import diagramapseudocodigo.Escribir
import diagramapseudocodigo.impl.EscribirImpl
import diagramapseudocodigo.impl.FuncionFicheroAbrirImpl
import diagramapseudocodigo.impl.FuncionFicheroCerrarImpl
import diagramapseudocodigo.Funcion
import diagramapseudocodigo.impl.FuncionImpl
import diagramapseudocodigo.Procedimiento
import diagramapseudocodigo.impl.ProcedimientoImpl
import diagramapseudocodigo.TipoVariable
import org.eclipse.emf.common.util.EList
import diagramapseudocodigo.TipoPaso
import diagramapseudocodigo.impl.DeclaracionVariableImpl
import diagramapseudocodigo.impl.DeclaracionPropiaImpl
import diagramapseudocodigo.ValorComplejo
import diagramapseudocodigo.ValorRegistro
import diagramapseudocodigo.impl.ValorRegistroImpl
import diagramapseudocodigo.ValorVector
import diagramapseudocodigo.impl.ValorVectorImpl
import diagramapseudocodigo.ValorMatriz
import diagramapseudocodigo.impl.ValorMatrizImpl
import diagramapseudocodigo.CampoRegistro
import diagramapseudocodigo.NumeroEntero
import diagramapseudocodigo.impl.NumeroEnteroImpl
import diagramapseudocodigo.NumeroDecimal
import diagramapseudocodigo.impl.NumeroDecimalImpl
import diagramapseudocodigo.ValorBooleano
import diagramapseudocodigo.impl.ValorBooleanoImpl
import diagramapseudocodigo.ConstCadena
import diagramapseudocodigo.impl.ConstCadenaImpl
import diagramapseudocodigo.Caracter
import diagramapseudocodigo.impl.CaracterImpl
import diagramapseudocodigo.impl.VariableIDImpl
import diagramapseudocodigo.operacion
import diagramapseudocodigo.impl.operacionImpl
import diagramapseudocodigo.Internas
import diagramapseudocodigo.impl.InternasImpl
import diagramapseudocodigo.unaria
import diagramapseudocodigo.impl.unariaImpl
import diagramapseudocodigo.booleano
import diagramapseudocodigo.NombreInterna
import diagramapseudocodigo.Suma
import diagramapseudocodigo.impl.SumaImpl
import diagramapseudocodigo.Resta
import diagramapseudocodigo.impl.RestaImpl
import diagramapseudocodigo.Multiplicacion
import diagramapseudocodigo.impl.MultiplicacionImpl
import diagramapseudocodigo.Division
import diagramapseudocodigo.impl.DivisionImpl
import diagramapseudocodigo.Or
import diagramapseudocodigo.impl.OrImpl
import diagramapseudocodigo.And
import diagramapseudocodigo.impl.AndImpl
import diagramapseudocodigo.Comparacion
import diagramapseudocodigo.impl.ComparacionImpl
import diagramapseudocodigo.Igualdad
import diagramapseudocodigo.impl.IgualdadImpl
import diagramapseudocodigo.Negativa
import diagramapseudocodigo.impl.NegativaImpl
import diagramapseudocodigo.Devolver
import diagramapseudocodigo.Sino
import org.eclipse.xtext.generator.JavaIoFileSystemAccess
import java.nio.file.Paths
import java.nio.charset.Charset
import java.util.List
import java.nio.file.Files
import java.io.File
import java.net.URL
import java.io.BufferedReader
import java.io.InputStreamReader
import java.io.IOException
import java.nio.file.Path
import java.util.logging.Logger

/**
 * Generates code from your model files on save.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#TutorialCodeGeneration
 */
class VaryGrammarGenerator implements IGenerator {
	@Inject extension IQualifiedNameProvider
	static Map<String, String> variablesInicio = new HashMap<String,String>();
	static Map<String, Map<String,String>>variablesSubprocesos = new HashMap<String,Map<String,String>>();
	static Map<String,String> vectoresMatrices = new HashMap<String,String>();
	static Map<String, Map<String,String>> registros = new HashMap<String, Map<String,String>>();
	static Map<String, ArrayList<String>> variablesEnumerados = new HashMap<String, ArrayList<String>>();
	static ArrayList<String> enumerados = new ArrayList<String>();
	static Codigo codigo;

	//EMap<String, TipoVariable> tablaSimbolos;
	override void doGenerate(Resource resource, IFileSystemAccess myCFile) {
		for (myPseudo : resource.allContents.toIterable.filter(typeof(Codigo))) {
			
			//Preparamos la URI del fichero .varyproject donde se registra el tipo de proyecto
			
			var uri = resource.getURI().toString();
			var i = 0;
			var nuevaUri = new String();
			while(i<uri.length()-15) {
				nuevaUri = nuevaUri + uri.charAt(i);
				i = i + 1;
			}
			nuevaUri = nuevaUri.replaceAll(":","");
			System.out.println("La nueva uri es:"+nuevaUri.toString())
			System.out.println("La uri cogida es:"+ProjectLocationFolder.getPath())
			//Problema para escapar la \ de Windows
			//System.out.println("La nueva uri es:"+nuevaUri.toString())
			//System.out.println("La uri antes es:"+uri.toString())
			//uri = uri.replaceAll("src"+File.separator+"Model","");
			//uri = uri.replaceAll(File.separator+"\\.vycpp","");
			//System.out.println("La uri despues es:"+uri.toString())
			var localizacion = new String();
			if(ProjectLocationFolder.getOS().equals("WIN32")) {
				localizacion = "file:///"+ProjectLocationFolder.getPath();
			}
			else {
				localizacion = "file:"+ProjectLocationFolder.getPath();
			}
			
				
			var path = Paths.get(localizacion, ".varyproject");
			
			//Leemos el fichero para elegir la opción al generar
			
			var contenidoFichero = new String();
			
			try {
        		var url = new URL(path.toString());
    			var inputStream = url.openConnection().getInputStream();
    			var in = new BufferedReader(new InputStreamReader(inputStream));
    			var inputLine = new String();
 
    			while ((inputLine = in.readLine()) != null) {
        			contenidoFichero = contenidoFichero + inputLine;
    			}
 
    			in.close();
 
			} catch (IOException e) {
    			e.printStackTrace();
			}
			
			//Recogemos el tipo de proyecto de la cadena
			
			var tipoProyecto = contenidoFichero.replaceAll("ficheroCabeceras=","");
			
			if(tipoProyecto == "No") {
				
				myCFile.generateFile("output.cpp", myPseudo.toCpp)
			}
			else {
				System.out.println("Na de na")
				myCFile.generateFile("output.cpp", myPseudo.toCpp)
				myCFile.generateFile("cabeceras.h", myPseudo.generarCabeceras)
			}
		}
	}
	
	def generarCabeceras(Codigo myCodigo) '''
		
		#ifndef CABECERAS_H
		#define CABECERAS_H
		
		«FOR funcion:myCodigo.funcion»
			«funcion.cabecerasFuncion»
		«ENDFOR»
		
		#endif /* CABECERAS_H */
	'''
	
	def cabecerasFuncion(Subproceso s) {
		if (s.eClass.name.equals("Funcion")) {
			var Funcion funcion = new FuncionImpl
			funcion = s as Funcion
			var cabecera = funcion.tipo.tipoVariableCpp + " " + funcion.nombre + "(";
			return variablesCabecerasSubproceso(funcion.parametrofuncion, cabecera);
			
		} else if (s.eClass.name.equals("Procedimiento")) {
			var Procedimiento procedimiento = new ProcedimientoImpl
			procedimiento = s as Procedimiento
			var cabecera = "void" + " " + procedimiento.nombre + "(";
			return variablesCabecerasSubproceso(procedimiento.parametrofuncion, cabecera);
		}
	}
	
	def variablesCabecerasSubproceso(EList<ParametroFuncion> parametros, String cabecera) {
		var cabeceraAux = cabecera;
		for(ParametroFuncion p: parametros) {
			cabeceraAux = cabeceraAux + p.tipo.toCpp + ","
		}
		cabeceraAux = cabeceraAux + ")"
		cabeceraAux = cabeceraAux.replaceAll("\\,\\)",")");
		cabeceraAux = cabeceraAux + ";"
		return cabeceraAux;
		
	}
	
	
	def toCpp(Codigo myCodigo) {
	
	codigo = myCodigo;
	
	for(TipoComplejo t: codigo.tipocomplejo) {
		if(t instanceof Enumerado) {
			var enumerado = t as Enumerado;
			variablesEnumerados.put(enumerado.nombre, new ArrayList<String>());
			enumerados.add(enumerado.nombre);
			for(valor v: enumerado.valor) {
			  if(v instanceof Operador) {
			  	var v2 = v as Operador
				if(v2 instanceof VariableID) {
					var aux = v2 as VariableID
					variablesEnumerados.get(enumerado.nombre).add(aux.nombre)
				}
			  }
			}
		}
	}
	
	for(Declaracion d: codigo.tiene.declaracion) {
		if(d instanceof DeclaracionVariable) {
			var dec = d as DeclaracionVariable;
			for(Variable v: dec.variable) {
				variablesInicio.put(v.nombre, dec.tipo.name);
			}
		}
		else if(d instanceof DeclaracionPropia) {
			var dec = d as DeclaracionPropia;
			for(Variable v: dec.variable) {
				variablesInicio.put(v.nombre, dec.tipo);
			}
		}
	}
	for(Subproceso s: codigo.funcion) {
		variablesSubprocesos.put(s.nombre, new HashMap<String,String>());
		for(Declaracion d: s.declaracion) {
			if(d instanceof DeclaracionVariable) {
				var dec = d as DeclaracionVariable;
				for(Variable v: dec.variable) {
					variablesSubprocesos.get(s.nombre).put(v.nombre, dec.tipo.name);
				}
			}
			else if(d instanceof DeclaracionPropia) {
				var dec = d as DeclaracionPropia;
				for(Variable v: dec.variable) {
					variablesSubprocesos.get(s.nombre).put(v.nombre, dec.tipo);
				}
			}
		}
		for(ParametroFuncion p: s.parametrofuncion) {
			if(p.tipo.eClass.name.equals("TipoExistente")) {
				var tipo = p.tipo as TipoExistente;
				variablesSubprocesos.get(s.nombre).put(p.variable.nombre, tipo.tipo.name);
			}
			else if(p.tipo.eClass.name.equals("TipoDefinido")) {
				var tipo = p.tipo as TipoDefinido;
				variablesSubprocesos.get(s.nombre).put(p.variable.nombre, tipo.tipo);
			}
		}
	}
	
	for(TipoComplejo t: codigo.tipocomplejo) {
		if(t.eClass.name.equals("Vector")) {
			var v = t as Vector;
			if(v.tipo.eClass.name.equals("TipoExistente")) {
				var tipo = v.tipo as TipoExistente;
				vectoresMatrices.put(v.nombre, tipo.tipo.name);
			}
			else if(v.tipo.eClass.name.equals("TipoDefinido")) {
				var tipo = v.tipo as TipoDefinido;
				vectoresMatrices.put(v.nombre, tipo.tipo);
			}
		}
		else if(t.eClass.name.equals("Matriz")) {
			var m = t as Matriz;
			if(m.tipo.eClass.name.equals("TipoExistente")) {
				var tipo = m.tipo as TipoExistente;
				vectoresMatrices.put(m.nombre, tipo.tipo.name);
			}
			else if(m.tipo.eClass.name.equals("TipoDefinido")) {
				var tipo = m.tipo as TipoDefinido;
				vectoresMatrices.put(m.nombre, tipo.tipo);
			}
		}
		else if(t.eClass.name.equals("Registro")) {
			var r = t as Registro;
			registros.put(r.nombre, new HashMap<String,String>());
			for(Declaracion d: r.variable) {
				if(d instanceof DeclaracionVariable) {
					var dec = d as DeclaracionVariable;
					for(Variable v: dec.variable) {
						registros.get(r.nombre).put(v.nombre, dec.tipo.name);
					}
				}
				else if(d instanceof DeclaracionPropia) {
					var dec = d as DeclaracionPropia;
					for(Variable v: dec.variable) {
						registros.get(r.nombre).put(v.nombre, dec.tipo);
					}
				}
			}
		}
	}
	
	'''
		#include <iostream>
		#include <string>
		#include <cmath>
		#include "cabeceras.h"
		
		using namespace std;
		«FOR myComentario:myCodigo.comentarios»
			«myComentario.toCpp»
		«ENDFOR»
		«FOR myConstante:myCodigo.constantes»
			«myConstante.toCpp»
		«ENDFOR»
		«FOR myComplejo:myCodigo.tipocomplejo»
			«myComplejo.toCpp»
		«ENDFOR»
		«FOR myVariable:myCodigo.global»
			«myVariable.toCpp»
		«ENDFOR»
		
		«FOR funcion:myCodigo.funcion»
			«funcion.toCpp»
			
		«ENDFOR»
		«myCodigo.tiene.toCpp»
	'''
	}
	
	def toCpp(TipoComplejo myComplejo) {
		if (myComplejo.eClass.name.equals("Vector")) {
			var Vector prueba = new VectorImpl
			prueba = myComplejo as Vector
			prueba.toCpp
		} else if (myComplejo.eClass.name.equals("Matriz")) {
			var Matriz prueba = new MatrizImpl
			prueba = myComplejo as Matriz
			prueba.toCpp
		} else if (myComplejo.eClass.name.equals("Registro")) {
			var Registro prueba = new RegistroImpl
			prueba = myComplejo as Registro
			prueba.toCpp
		} else if (myComplejo.eClass.name.equals("Archivo")) {
			var Archivo prueba = new ArchivoImpl
			prueba = myComplejo as Archivo
			prueba.toCpp
		} else if (myComplejo.eClass.name.equals("Enumerado")) {
			var Enumerado prueba = new EnumeradoImpl
			prueba = myComplejo as Enumerado
			prueba.toCpp
		} else if (myComplejo.eClass.name.equals("SubrangoNumerico")) {
			var SubrangoNumerico prueba = new SubrangoNumericoImpl
			prueba = myComplejo as SubrangoNumerico
			prueba.toCpp
		} else if (myComplejo.eClass.name.equals("SubrangoEnumerado")) {
			var SubrangoEnumerado prueba = new SubrangoEnumeradoImpl
			prueba = myComplejo as SubrangoEnumerado
			prueba.toCpp
		}
	}

	def toCpp(Tipo myTipo) {
		if (myTipo.eClass.name.equals("TipoDefinido")) {
			var TipoDefinido prueba = new TipoDefinidoImpl
			prueba = myTipo as TipoDefinido
			prueba.toCpp
		} else if (myTipo.eClass.name.equals("TipoExistente")) {
			var TipoExistente prueba = new TipoExistenteImpl
			prueba = myTipo as TipoExistente
			prueba.toCpp
		}
	}

	def toCpp(TipoExistente myTipo) {
		return tipoVariableCpp(myTipo.tipo)
	}
	
	def toCpp(Comentario myComentario)
		'''«myComentario.mensaje»'''

	def toCpp(TipoDefinido myTipo) {
		return myTipo.tipo
	}

	def toCpp(Constantes myConstante) '''
		#define «myConstante.variable.nombre»  «myConstante.valor.toCpp»
	'''

	def toCpp(Vector myVector) '''
		typedef «myVector.tipo.toCpp» «myVector.nombre»[«myVector.valor.toCpp»];
	'''

	def toCpp(Matriz myMatriz) '''
		typedef «myMatriz.tipo.toCpp» «myMatriz.nombre»[«myMatriz.valor.get(0).toCpp»][«myMatriz.valor.get(1).toCpp»];
	'''
	
	def toCpp(Registro myRegistro) '''
		typedef struct {
			«FOR myVariable:myRegistro.variable»
				«myVariable.toCpp»
			«ENDFOR»
		} «myRegistro.nombre»;
	'''

	def toCpp(Archivo myArchivo) '''
		typedef FILE *«myArchivo.nombre»;
	'''

	def toCpp(Enumerado myEnumerado) '''
		typedef enum {«FOR myVariable:myEnumerado.valor»«IF myVariable == myEnumerado.valor.get(myEnumerado.valor.size()-1)»«myVariable.toCpp»«ELSE»«myVariable.toCpp», «ENDIF»«ENDFOR»} «myEnumerado.nombre»;
	'''
	
	def toCpp(SubrangoNumerico mySubrango) '''
		typedef enum {«generaSubrango(mySubrango.limite_inf,mySubrango.limite_sup)»} «mySubrango.nombre»;
	'''
	
	def toCpp(SubrangoEnumerado mySubrango) '''
		typedef enum {«generaSubrangoEnumerado(mySubrango.limite_inf,mySubrango.limite_sup)»} «mySubrango.nombre»;
	'''
	
	def obtenerModo(String modo) {
		if(modo == "escritura") {
			return "w";
		}
		else if(modo == "lectura") {
			return "r";
		}
	}
	
	def toCpp(FuncionFicheroAbrir myFuncionFicheroAbrir) '''
		«myFuncionFicheroAbrir.variable.get(0).toCpp» = fopen(«myFuncionFicheroAbrir.variable.get(1).toCpp»,"«obtenerModo(myFuncionFicheroAbrir.modo.getName)»")
	'''
	
	def toCpp(FuncionFicheroCerrar myFuncionFicheroCerrar)'''
		fclose(«myFuncionFicheroCerrar.variable.toCpp»)
	'''

	def generaSubrango(int limite_inf,int limite_sup) {
		var concat = new String
		var i = limite_inf
		while (i < limite_sup) {
			concat = concat + i + ", "
			i = i + 1
		}
		concat = concat + i;
		return concat;
	}
	
	def generaSubrangoEnumerado(String limite_inf, String limite_sup) {
		var concat = new String
		for(String nombre: enumerados) {
			if(variablesEnumerados.get(nombre).contains(limite_inf) && variablesEnumerados.get(nombre).contains(limite_sup)) {
				var index_limite_inf = variablesEnumerados.get(nombre).indexOf(limite_inf);
				var index_limite_sup = variablesEnumerados.get(nombre).indexOf(limite_sup);
				var sublista = variablesEnumerados.get(nombre).subList(index_limite_inf, index_limite_sup);
				for(String aux: sublista) {
					concat = concat + aux + ", "
				}
				concat = concat + limite_sup
				return concat
			}
		}
	}
	
	def toCpp(Inicio myInicio) '''
		int main(){
			«FOR myVariable:myInicio.declaracion»
				«myVariable.toCpp»
			«ENDFOR»
			«FOR mySentencia:myInicio.tiene»
					«mySentencia.toCpp»
			«ENDFOR»
		}
	'''
	
	def toCpp(Subproceso subp) {
		if (subp.eClass.name.equals("Funcion")) {
			var Funcion prueba = new FuncionImpl
			prueba = subp as Funcion
			prueba.toCpp
		} else if (subp.eClass.name.equals("Procedimiento")) {
			var Procedimiento prueba = new ProcedimientoImpl
			prueba = subp as Procedimiento
			prueba.toCpp
		}
	}

	def tipoVariableCpp(TipoVariable tipo) {
		if(tipo == TipoVariable::ENTERO) return "int";
		if(tipo == TipoVariable::CARACTER) return "char";
		if(tipo == TipoVariable::REAL) return "float";
		if(tipo == TipoVariable::LOGICO) return "bool";
		if(tipo == TipoVariable::CADENA) return "string";
	}
	
	def tipoVariableCppDeclaraciones(TipoVariable tipo) {
		if(tipo == TipoVariable::ENTERO) return "int";
		if(tipo == TipoVariable::CARACTER) return "char";
		if(tipo == TipoVariable::REAL) return "float";
		if(tipo == TipoVariable::LOGICO) return "bool";
	}

	def toCpp(EList<ParametroFuncion> parametros) {
		var total = "";
		var actual = 1;
		for (p : parametros) {
			if (actual != 1)
				total = total + ", "
			if (p.paso == TipoPaso::ENTRADA) {
				total = total + "const " + p.tipo.toCpp + " " + p.variable.nombre;
			} else if (p.paso == TipoPaso::ENTRADA_SALIDA) {
				total = total + p.tipo.toCpp + "* " + p.variable.nombre;
			} else {
				total = total + p.tipo.toCpp + "* " + p.variable.nombre;
			}
			actual = actual + 1;
		}
		return total;
	}

	def toCpp(Funcion myFun) '''
		«myFun.tipo.tipoVariableCpp» «myFun.nombre»(«myFun.parametrofuncion.toCpp»){
			«FOR myVariable:myFun.declaracion»
				«myVariable.toCpp»
			«ENDFOR»
			«FOR mySentencia:myFun.sentencias»
				«mySentencia.toCpp»
			«ENDFOR»
			«IF myFun.devuelve != null» 
			«myFun.devuelve.toCpp»
			«ENDIF»
		}
	'''

	def toCpp(Procedimiento myFun) '''
		void «myFun.nombre»(«myFun.parametrofuncion.toCpp»){
			«FOR myVariable:myFun.declaracion»
				«myVariable.toCpp»
			«ENDFOR»
			«FOR mySentencia:myFun.sentencias»
				«mySentencia.toCpp»
			«ENDFOR»
		}
	'''
	
	def toCpp(Sentencias mySent) {
		if (mySent.eClass.name.equals("AsignacionNormal")) {
			var AsignacionNormal prueba = new AsignacionNormalImpl
			prueba = mySent as AsignacionNormal
			prueba.toCpp
		} else if (mySent.eClass.name.equals("AsignacionCompleja")) {
			var AsignacionCompleja prueba = new AsignacionComplejaImpl
			prueba = mySent as AsignacionCompleja
			prueba.toCpp
		}else if (mySent.eClass.name.equals("LlamadaFuncion")) {
			var LlamadaFuncion prueba = new LlamadaFuncionImpl
			prueba = mySent as LlamadaFuncion
			prueba.toCpp(true)
		} else if (mySent.eClass.name.equals("Si")) {
			var Si prueba = new SiImpl
			prueba = mySent as Si
			prueba.toCpp
		} else if (mySent.eClass.name.equals("segun")) {
			var segun prueba = new segunImpl
			prueba = mySent as segun
			prueba.toCpp
		} else if (mySent.eClass.name.equals("Caso")) {
			var Caso prueba = new CasoImpl
			prueba = mySent as Caso
			prueba.toCpp
		} else if (mySent.eClass.name.equals("mientras")) {
			var mientras prueba = new mientrasImpl
			prueba = mySent as mientras
			prueba.toCpp
		} else if (mySent.eClass.name.equals("repetir")) {
			var repetir prueba = new repetirImpl
			prueba = mySent as repetir
			prueba.toCpp
		} else if (mySent.eClass.name.equals("desde")) {
			var desde prueba = new desdeImpl
			prueba = mySent as desde
			prueba.toCpp
		} else if (mySent.eClass.name.equals("Negacion")) {
			var Negacion prueba = new NegacionImpl
			prueba = mySent as Negacion
			prueba.toCpp
		} else if (mySent.eClass.name.equals("Leer")) {
			var Leer prueba = new LeerImpl
			prueba = mySent as Leer
			prueba.toCpp
		} else if (mySent.eClass.name.equals("Escribir")) {
			var Escribir prueba = new EscribirImpl
			prueba = mySent as Escribir
			prueba.toCpp
		} else if (mySent.eClass.name.equals("FuncionFicheroAbrir")) {
			var FuncionFicheroAbrir prueba = new FuncionFicheroAbrirImpl
			prueba = mySent as FuncionFicheroAbrir
			prueba.toCpp
		} else if (mySent.eClass.name.equals("FuncionFicheroCerrar")) {
			var FuncionFicheroCerrar prueba = new FuncionFicheroCerrarImpl
			prueba = mySent as FuncionFicheroCerrar
			prueba.toCpp
		}	
	}
	

	def pintarVariables(EList<Variable> v) '''
		«v.get(0).nombre»«FOR matri:v.get(0).mat»«matri.toString»«ENDFOR»«FOR id:v»«IF id.nombre != v.get(0).nombre», «id.nombre»«FOR matri2:id.mat»«matri2.toString»«ENDFOR»«ENDIF»«ENDFOR»;	
	'''
	def pintarVariablesCadena(EList<Variable> v) {
		var resultado = v.get(0).nombre;
		for(matri: v.get(0).mat) {
			resultado = resultado + matri.toString;
		}
		for(id: v) {
			if(id.nombre != v.get(0).nombre) {
				resultado = resultado + " ," + id.nombre;
				for(matri2: id.mat) {
					resultado = resultado + matri2.toString;
				}
			}
		}
		return resultado;
	}

	// «myDec.tieneIDs.get(0).nombre»«FOR id:myDec.tieneIDs»«IF id.nombre != myDec.tieneIDs.get(0).nombre», «id.nombre»«ENDIF»«ENDFOR»;
	
	def toCpp(Declaracion myDec) {
		if (myDec.eClass.name.equals("DeclaracionVariable")) {
			var DeclaracionVariable prueba = new DeclaracionVariableImpl
			prueba = myDec as DeclaracionVariable
			prueba.toCpp
		} else if (myDec.eClass.name.equals("DeclaracionPropia")) {
			var DeclaracionPropia prueba = new DeclaracionPropiaImpl
			prueba = myDec as DeclaracionPropia
			prueba.toCpp
		}

	}
	
	def toCpp(DeclaracionPropia myDec) '''
		«myDec.tipo» «pintarVariables(myDec.variable)»
	'''
	
	def toCpp(DeclaracionVariable myDec) '''
		«myDec.tipo.tipoVariableCpp» «pintarVariables(myDec.variable)»
	'''

	//def toC(Asignacion myAsig) '''
	//	«myAsig.valor_asignacion»«FOR matri:myAsig.mat»«matri.toString»«ENDFOR» = «myAsig.operadores.toC»;'''

	def toCpp(AsignacionNormal asig) '''
	«asig.valor_asignacion»«FOR matri:asig.mat»«matri.toString»«ENDFOR» = «asig.operador.toCpp»;'''

	def toCpp(AsignacionCompleja asig) '''
	«asig.valor_asignacion.toCpp.toString» = «asig.operador.toCpp.toString»;'''

	def toCpp(ValorComplejo myComplejo) {
		if (myComplejo.eClass.name.equals("ValorRegistro")) {
			var ValorRegistro prueba = new ValorRegistroImpl
			prueba = myComplejo as ValorRegistro
			prueba.toCpp
		}
		else if(myComplejo.eClass.name.equals("ValorVector")) {
			var ValorVector prueba = new ValorVectorImpl
			prueba = myComplejo as ValorVector
			prueba.toCpp
		}
		else if(myComplejo.eClass.name.equals("ValorMatriz")) {
			var ValorMatriz prueba = new ValorMatrizImpl
			prueba = myComplejo as ValorMatriz
			prueba.toCpp
		}
	}

	def toCpp(ValorRegistro myValor) {

		//Este metodo esta escrito con otra sintaxis diferente porque me generaba un salto de linea innecesario
		var concat = new String;
		concat = myValor.nombre_registro.toString + '.'
		for (myVariable : myValor.campo) {
			concat = concat + myVariable.toCpp.toString;
		}
		return concat;
	}

	def toCpp(ValorVector myValor) {
		var concat = new String;
		if(myValor.campo.size() == 0) {
			concat = myValor.nombre_vector.toString + '[' + myValor.indice.toCpp + ']';
		}
		else {
			concat = myValor.nombre_vector.toString + '[' + myValor.indice.toCpp + ']' + '.' + myValor.campo.get(0).nombre_campo;
		}
		return concat;
	}

	def toCpp(CampoRegistro myCampo) {

		//Este metodo esta escrito con otra sintaxis diferente porque me generaba un salto de linea innecesario
		return myCampo.nombre_campo;
	}

	def toCpp(ValorMatriz myValor) {
		var concat = new String;
		if(myValor.campo.size() == 0) {
			concat = myValor.nombre_matriz.toString + '[' + myValor.primerIndice.toCpp + '][' + myValor.segundoIndice.toCpp + ']';
		}
		else {
			concat = myValor.nombre_matriz.toString + '[' + myValor.primerIndice.toCpp + '][' + myValor.segundoIndice.toCpp + ']' + '.' + myValor.campo.get(0).nombre_campo;
		}
		return concat;
	}

	def toCpp(valor myVal) {
		if (myVal.eClass.name.equals("NumeroEntero")) {
			var NumeroEntero prueba = new NumeroEnteroImpl
			prueba = myVal as NumeroEntero
			prueba.toCpp
		} else if (myVal.eClass.name.equals("NumeroDecimal")) {
			var NumeroDecimal prueba = new NumeroDecimalImpl
			prueba = myVal as NumeroDecimal
			prueba.toCpp
		} else if (myVal.eClass.name.equals("ValorBooleano")) {
			var ValorBooleano prueba = new ValorBooleanoImpl
			prueba = myVal as ValorBooleano
			prueba.toCpp
		} else if (myVal.eClass.name.equals("ConstCadena")) {
			var ConstCadena prueba = new ConstCadenaImpl
			prueba = myVal as ConstCadena
			prueba.toCpp
		} else if (myVal.eClass.name.equals("Caracter")) {
			var Caracter prueba = new CaracterImpl
			prueba = myVal as Caracter
			prueba.toCpp
		} else if (myVal.eClass.name.equals("VariableID")) {
			var VariableID prueba = new VariableIDImpl
			prueba = myVal as VariableID
			prueba.toCpp
		} else if (myVal.eClass.name.equals("LlamadaFuncion")) {
			var LlamadaFuncion prueba = new LlamadaFuncionImpl
			prueba = myVal as LlamadaFuncion
			prueba.toCpp(false)
		} else if (myVal.eClass.name.equals("operacion")) {
			var operacion prueba = new operacionImpl
			prueba = myVal as operacion
			prueba.toCpp
		} else if (myVal.eClass.name.equals("Internas")) {
			var Internas prueba = new InternasImpl
			prueba = myVal as Internas
			prueba.toCpp
		} else if (myVal.eClass.name.equals("unaria")) {
			var unaria prueba = new unariaImpl
			prueba = myVal as unaria
			prueba.toCpp
		} else if (myVal.eClass.name.equals("ValorRegistro")) {
			var ValorRegistro prueba = new ValorRegistroImpl
			prueba = myVal as ValorRegistro
			prueba.toCpp
		} else if (myVal.eClass.name.equals("ValorVector")) {
			var ValorVector prueba = new ValorVectorImpl
			prueba = myVal as ValorVector
			prueba.toCpp
		} else if (myVal.eClass.name.equals("ValorMatriz")) {
			var ValorMatriz prueba = new ValorMatrizImpl
			prueba = myVal as ValorMatriz
			prueba.toCpp
		}
	}

	def toCpp(NumeroEntero numero) {
		return numero.valor.toString
	}

	def toCpp(NumeroDecimal numero) {
		return numero.valor.toString
	}

	def toCpp(ValorBooleano valBool) {
		if (valBool.valor == booleano::VERDADERO)
			return "true"
		else
			return "false"
	}

	def toCpp(ConstCadena cadena) {
		print(cadena.contenido)
	}

	def toCpp(Caracter caract) {
		print(caract.contenido)
	}

	def toCpp(VariableID variable) '''
	«variable.nombre»«FOR matri:variable.mat»«matri.toString»«ENDFOR»'''

	//def toC(negacion neg) '''
	//	«neg.nombre»«neg.ssigno»;
	//'''

	def toCpp(unaria myUnaria) {
		return "!" + myUnaria.variable.toCpp;
	}

	def toCpp(Leer l) '''
		cin >> «l.variable.toCpp»;
	'''
	
	def contienenExpresionLeer(EList<Sentencias> sentencias, Leer l) {
		if(sentencias.contains(l)) {
			return true;
		}
		for(Sentencias s: sentencias) {
			if(s.eClass.name.equals("mientras")) {
				var mientras = s as mientras;
				if(mientras.sentencias.contains(l)) {
					return true;
				}
				else {
					if(contienenExpresionLeer(mientras.sentencias, l) == true) {
						return true;
					}
				}
			}
			else if(s.eClass.name.equals("repetir")) {
				var repetir = s as repetir;
				if(repetir.sentencias.contains(l)) {
					return true;
				}
				else {
					if(contienenExpresionLeer(repetir.sentencias, l) == true) {
						return true;
					}
				}
			}
			else if(s.eClass.name.equals("desde")) {
				var desde = s as desde;
				if(desde.sentencias.contains(l)) {
					return true;
				}
				else {
					if(contienenExpresionLeer(desde.sentencias, l) == true) {
						return true;
					}
				}
			}
			else if(s.eClass.name.equals("Si")) {
				var si = s as Si;
				if(si.sentencias.contains(l)) {
					return true;
				}
				else if(si.sino != null) {
					if(si.sino.sentencias.contains(l)) {
						return true;
					}
					else {
						if(contienenExpresionLeer(si.sino.sentencias, l) == true) {
							return true;
						}
					}
				}
				else {
					if(contienenExpresionLeer(si.sentencias, l) == true) {
						return true;
					}
				}
			}
			else if(s.eClass.name.equals("segun")) {
				var segun = s as segun;
				for(Caso c: segun.caso) {
					if(c.sentencias.contains(l)) {
						return true;
					}
					else {
						if(contienenExpresionLeer(c.sentencias, l) == true) {
							return true;
						}
					}
				}
			}
		}
		return false;
	}
	
	def toC(Leer l) {
		var perteneceInicio = false;
		if(!codigo.tiene.tiene.contains(l)) {
			for(Sentencias s: codigo.tiene.tiene) {
				if(s.eClass.name.equals("mientras") && perteneceInicio == false) {
					var mientras = s as mientras;
					perteneceInicio = contienenExpresionLeer(mientras.sentencias, l);
				}
				else if(s.eClass.name.equals("repetir") && perteneceInicio == false) {
					var repetir = s as repetir;
					perteneceInicio = contienenExpresionLeer(repetir.sentencias, l);
				}
				else if(s.eClass.name.equals("desde") && perteneceInicio == false) {
					var desde = s as desde;
					perteneceInicio = contienenExpresionLeer(desde.sentencias, l);
				}
				else if(s.eClass.name.equals("Si") && perteneceInicio == false) {
					var si = s as Si;
					perteneceInicio = contienenExpresionLeer(si.sentencias, l);
					if(si.sino != null) {
						perteneceInicio = contienenExpresionLeer(si.sino.sentencias, l);
					}
				}	
				else if(s.eClass.name.equals("segun") && perteneceInicio == false) {
					var segun = s as segun;
					for(Caso c: segun.caso) {
						if(perteneceInicio == false) {
							perteneceInicio = contienenExpresionLeer(c.sentencias, l);
						}
					}
				}
		 	}
		}
		if(codigo.tiene.tiene.contains(l) || perteneceInicio) {
			var tipo = "";
			if(l.variable.eClass.name.equals("VariableID")) {
				var varID = l.variable as VariableID;
				tipo = variablesInicio.get(varID.nombre);
			}
			else if(l.variable.eClass.name.equals("ValorVector")) {
				var vector = l.variable as ValorVector;
				if(vector.campo.size() == 0) {
					tipo = vectoresMatrices.get(variablesInicio.get(vector.nombre_vector));
				}
				else {
					tipo = registros.get(vectoresMatrices.get(variablesInicio.get(vector.nombre_vector))).get(vector.campo.get(0).nombre_campo);
				}
			}
			else if(l.variable.eClass.name.equals("ValorMatriz")) {
				var matriz = l.variable as ValorMatriz;
				if(matriz.campo.size() == 0) {
					tipo = vectoresMatrices.get(variablesInicio.get(matriz.nombre_matriz));
				}
				else {
					tipo = registros.get(vectoresMatrices.get(variablesInicio.get(matriz.nombre_matriz))).get(matriz.campo.get(0).nombre_campo);
				}
			}
			else if(l.variable.eClass.name.equals("ValorRegistro")) {
				var registro = l.variable as ValorRegistro;
				tipo = registros.get(variablesInicio.get(registro.nombre_registro)).get(registro.campo.get(0).nombre_campo);
			}
			if(tipo == "ENTERO") {
				'''scanf("%i", &«l.variable.toCpp»);'''
			}
			else if(tipo == "CARACTER") {
				'''scanf("%c", &«l.variable.toCpp»);'''
			}
			else if(tipo == "CADENA") {
				'''scanf("%s", &«l.variable.toCpp»);'''
			}
			else if(tipo == "REAL") {
				'''scanf("%r", &«l.variable.toCpp»);'''
			}
		}
		else {
			for(Subproceso s: codigo.funcion) {
				var perteneceSubproceso = false;
				if(!s.sentencias.contains(l)) {
					for(Sentencias sent: s.sentencias) {
						if(sent.eClass.name.equals("mientras") && perteneceSubproceso == false) {
						var mientras = sent as mientras;
						perteneceSubproceso = contienenExpresionLeer(mientras.sentencias, l);
					}
					else if(sent.eClass.name.equals("repetir") && perteneceSubproceso == false) {
						var repetir = sent as repetir;
						perteneceSubproceso = contienenExpresionLeer(repetir.sentencias, l);
					}
					else if(sent.eClass.name.equals("desde") && perteneceSubproceso == false) {
						var desde = sent as desde;
						perteneceSubproceso = contienenExpresionLeer(desde.sentencias, l);
					}
					else if(sent.eClass.name.equals("Si") && perteneceSubproceso == false) {
						var si = sent as Si;
						perteneceSubproceso = contienenExpresionLeer(si.sentencias, l);
						if(si.sino != null) {
							perteneceSubproceso = contienenExpresionLeer(si.sino.sentencias, l);
						}
					}	
					else if(sent.eClass.name.equals("segun") && perteneceSubproceso == false) {
						var segun = sent as segun;
						for(Caso c: segun.caso) {
							if(perteneceSubproceso == false) {
								perteneceSubproceso = contienenExpresionLeer(c.sentencias, l);
							}
						}
					}
		 		}
		 	}
		 	if(s.sentencias.contains(l) || perteneceSubproceso) {
		 		var tipo = "";
				if(l.variable.eClass.name.equals("VariableID")) {
						var varID = l.variable as VariableID;
						tipo = variablesSubprocesos.get(s.nombre).get(varID.nombre);
				}
				else if(l.variable.eClass.name.equals("ValorVector")) {
					var vector = l.variable as ValorVector;
					if(vector.campo.size() == 0) {
						tipo = vectoresMatrices.get(variablesSubprocesos.get(s.nombre).get(vector.nombre_vector));
					}
					else {
						tipo = registros.get(vectoresMatrices.get(variablesSubprocesos.get(s.nombre).get(vector.nombre_vector))).get(vector.campo.get(0).nombre_campo);
					}
				}
				else if(l.variable.eClass.name.equals("ValorMatriz")) {
					var matriz = l.variable as ValorMatriz;
					if(matriz.campo.size() == 0) {
						tipo = vectoresMatrices.get(variablesSubprocesos.get(s.nombre).get(matriz.nombre_matriz));
					}
					else {
						tipo = registros.get(vectoresMatrices.get(variablesSubprocesos.get(s.nombre).get(matriz.nombre_matriz))).get(matriz.campo.get(0).nombre_campo);
					}
				}	
				else if(l.variable.eClass.name.equals("ValorRegistro")) {
					var registro = l.variable as ValorRegistro;
					tipo = registros.get(variablesSubprocesos.get(s.nombre).get(registro.nombre_registro)).get(registro.campo.get(0).nombre_campo);
				}
				if(tipo == "ENTERO") {
					return '''scanf("%i", &«l.variable.toCpp»);'''
				}
				else if(tipo == "CARACTER") {
					return '''scanf("%c", &«l.variable.toCpp»);'''
				}
				else if(tipo == "CADENA") {
					return '''scanf("%s", &«l.variable.toCpp»);'''
				}
				else if(tipo == "REAL") {
					return '''scanf("%r", &«l.variable.toCpp»);'''
				}
			}
		}
		}
	}

	def toCpp(Internas i) {
		if (i.nombre == NombreInterna::COS) {
			'''cos(«i.operadores.get(0).toCpp»)'''
		} else if (i.nombre == NombreInterna::SEN) {
			'''sin(«i.operadores.get(0).toCpp»)'''
		} else if (i.nombre == NombreInterna::CUADRADO) {
			'''pow(«i.operadores.get(0).toCpp»,«2.0»)'''
		} else if (i.nombre == NombreInterna::EXP) {
			'''exp2(«i.operadores.get(0).toCpp»)'''
		} else if (i.nombre == NombreInterna::LN) {
			'''log(«i.operadores.get(0).toCpp»)'''
		} else if (i.nombre == NombreInterna::LOG) {
			'''log10(«i.operadores.get(0).toCpp»)'''
		} else if (i.nombre == NombreInterna::SQRT) {
			'''sqrt(«i.operadores.get(0).toCpp»)'''
		} else if (i.nombre == NombreInterna::LONGITUD) {
			'''strlen(«i.operadores.get(0).toCpp»)'''
		} else if (i.nombre == NombreInterna::CONCATENA) {
			'''strcat(«i.operadores.get(0).toCpp»,«i.operadores.get(1).toCpp»)'''
		} 
	}

	def coutOperadores(EList<operacion> operaciones) {
		var resultado = "";
		for (op : operaciones) {
			resultado = resultado + " << " + op.toCpp;
		}
		return resultado;
	}
	
	def contienenExpresionEscribir(EList<Sentencias> sentencias, Escribir e) {
		if(sentencias.contains(e)) {
			return true;
		}
		for(Sentencias s: sentencias) {
			if(s.eClass.name.equals("mientras")) {
				var mientras = s as mientras;
				if(mientras.sentencias.contains(e)) {
					return true;
				}
				else {
					if(contienenExpresionEscribir(mientras.sentencias, e) == true) {
						return true;
					}
				}
			}
			else if(s.eClass.name.equals("repetir")) {
				var repetir = s as repetir;
				if(repetir.sentencias.contains(e)) {
					return true;
				}
				else {
					if(contienenExpresionEscribir(repetir.sentencias, e) == true) {
						return true;
					}
				}
			}
			else if(s.eClass.name.equals("desde")) {
				var desde = s as desde;
				if(desde.sentencias.contains(e)) {
					return true;
				}
				else {
					if(contienenExpresionEscribir(desde.sentencias, e) == true) {
						return true;
					}
				}
			}
			else if(s.eClass.name.equals("Si")) {
				var si = s as Si;
				if(si.sentencias.contains(e)) {
					return true;
				}
				else if(si.sino != null) {
					if(si.sino.sentencias.contains(e)) {
						return true;
					}
					else {
						if(contienenExpresionEscribir(si.sino.sentencias, e) == true) {
							return true;
						}
					}
				}
				else {
					if(contienenExpresionEscribir(si.sentencias, e) == true) {
						return true;
					}
				}
			}
			else if(s.eClass.name.equals("segun")) {
				var segun = s as segun;
				for(Caso c: segun.caso) {
					if(c.sentencias.contains(e)) {
						return true;
					}
					else {
						if(contienenExpresionEscribir(c.sentencias, e) == true) {
							return true;
						}
					}
				}
			}
		}
		return false;
	}

	def toCpp(Escribir a) '''
		cout«a.operador.coutOperadores» << endl;
	'''

	def generaParametros(EList<operacion> operaciones) {
		var total = "";
		var actual = 1;
		for (op : operaciones) {
			if (actual != 1)
				total = total + ", "
			total = total + op.toCpp;
			actual = actual + 1;
		}
		return total;
	}

	def toCpp(LlamadaFuncion fun, boolean a) '''«fun.nombre»(«fun.operadores.generaParametros»)«IF a»;«ENDIF»'''

	def toCpp(Operador op) {
		if (op.eClass.name.equals("NumeroEntero")) {
			var NumeroEntero prueba = new NumeroEnteroImpl
			prueba = op as NumeroEntero
			prueba.toCpp
		} else if (op.eClass.name.equals("NumeroDecimal")) {
			var NumeroDecimal prueba = new NumeroDecimalImpl
			prueba = op as NumeroDecimal
			prueba.toCpp
		} else if (op.eClass.name.equals("ValorBooleano")) {
			var ValorBooleano prueba = new ValorBooleanoImpl
			prueba = op as ValorBooleano
			prueba.toCpp
		} else if (op.eClass.name.equals("ConstCadena")) {
			var ConstCadena prueba = new ConstCadenaImpl
			prueba = op as ConstCadena
			prueba.toCpp
		} else if (op.eClass.name.equals("Caracter")) {
			var Caracter prueba = new CaracterImpl
			prueba = op as Caracter
			prueba.toCpp
		} else if (op.eClass.name.equals("VariableID")) {
			var VariableID prueba = new VariableIDImpl
			prueba = op as VariableID
			prueba.toCpp
		}
		else if (op.eClass.name.equals("ValorRegistro")) {
			var ValorRegistro prueba = new ValorRegistroImpl
			prueba = op as ValorRegistro
			prueba.toCpp
		}
		else if (op.eClass.name.equals("ValorVector")) {
			var ValorVector prueba = new ValorVectorImpl
			prueba = op as ValorVector
			prueba.toCpp
		}
		else if (op.eClass.name.equals("ValorMatriz")) {
			var ValorMatriz prueba = new ValorMatrizImpl
			prueba = op as ValorMatriz
			prueba.toCpp
		}
	}

	def toCpp(operacion op) {
		if (op.eClass.name.equals("NumeroEntero")) {
			var NumeroEntero prueba = new NumeroEnteroImpl
			prueba = op as NumeroEntero
			prueba.toCpp	
		} else if (op.eClass.name.equals("NumeroDecimal")) {
			var NumeroDecimal prueba = new NumeroDecimalImpl
			prueba = op as NumeroDecimal
			prueba.toCpp
		} else if (op.eClass.name.equals("ValorBooleano")) {
			var ValorBooleano prueba = new ValorBooleanoImpl
			prueba = op as ValorBooleano
			prueba.toCpp
		} else if (op.eClass.name.equals("ConstCadena")) {
			var ConstCadena prueba = new ConstCadenaImpl
			prueba = op as ConstCadena
			prueba.toCpp
		} else if (op.eClass.name.equals("Caracter")) {
			var Caracter prueba = new CaracterImpl
			prueba = op as Caracter
			prueba.toCpp
		} else if (op.eClass.name.equals("VariableID")) {
			var VariableID prueba = new VariableIDImpl
			prueba = op as VariableID
			prueba.toCpp
		}
		else if (op.eClass.name.equals("ValorRegistro")) {
			var ValorRegistro prueba = new ValorRegistroImpl
			prueba = op as ValorRegistro
			prueba.toCpp
		}
		else if (op.eClass.name.equals("ValorVector")) {
			var ValorVector prueba = new ValorVectorImpl
			prueba = op as ValorVector
			prueba.toCpp
		}
		else if (op.eClass.name.equals("ValorMatriz")) {
			var ValorMatriz prueba = new ValorMatrizImpl
			prueba = op as ValorMatriz
			prueba.toCpp
		}
		else if (op.eClass.name.equals("LlamadaFuncion")) {
			var LlamadaFuncion prueba = new LlamadaFuncionImpl
			prueba = op as LlamadaFuncion
			prueba.toCpp(false)
		}
		else if (op.eClass.name.equals("Internas")) {
			var Internas prueba = new InternasImpl
			prueba = op as Internas
			prueba.toCpp
		}
		else if (op.eClass.name.equals("Suma")) {
			var Suma prueba = new SumaImpl
			prueba = op as Suma
			prueba.toCpp
		}
		else if (op.eClass.name.equals("Resta")) {
			var Resta prueba = new RestaImpl
			prueba = op as Resta
			prueba.toCpp
		}
		else if (op.eClass.name.equals("Multiplicacion")) {
			var Multiplicacion prueba = new MultiplicacionImpl
			prueba = op as Multiplicacion
			prueba.toCpp
		}
		else if (op.eClass.name.equals("Division")) {
			var Division prueba = new DivisionImpl
			prueba = op as Division
			prueba.toCpp
		}
		else if (op.eClass.name.equals("Or")) {
			var Or prueba = new OrImpl
			prueba = op as Or
			prueba.toCpp
		}
		else if (op.eClass.name.equals("And")) {
			var And prueba = new AndImpl
			prueba = op as And
			prueba.toCpp
		}
		else if (op.eClass.name.equals("Comparacion")) {
			var Comparacion prueba = new ComparacionImpl
			prueba = op as Comparacion
			prueba.toCpp
		}
		else if (op.eClass.name.equals("Igualdad")) {
			var Igualdad prueba = new IgualdadImpl
			prueba = op as Igualdad
			prueba.toCpp
		}
		else if (op.eClass.name.equals("Negativa")) {
			var Negativa prueba = new NegativaImpl
			prueba = op as Negativa
			prueba.toCpp
		}
		else if (op.eClass.name.equals("Negacion")) {
			var Negacion prueba = new NegacionImpl
			prueba = op as Negacion
			prueba.toCpp
		}
	}
	
	def toCpp(Suma mySuma) {
		return mySuma.left.toCpp + " " + mySuma.signo_op + " " + mySuma.right.toCpp;
	}
	
	def toCpp(Resta myResta) {
		return myResta.left.toCpp + " " + myResta.signo_op + " " + myResta.right.toCpp;
	}
	
	def toCpp(Multiplicacion myMulti) {
		return myMulti.left.toCpp + " " + myMulti.signo_op + " " + myMulti.right.toCpp;
	}
	
	def toCpp(Division myDivi) {
		return myDivi.left.toCpp + " " + myDivi.signo_op + " " + myDivi.right.toCpp;
	}
	
	def toCpp(Or myOr) {
		return myOr.left.toCpp + " " + "||" + " " + myOr.right.toCpp;
	}
	
	def toCpp(And myAnd) {
		return myAnd.left.toCpp + " " + "&&" + " " + myAnd.right.toCpp;
	}
	
	def toCpp(Comparacion myComparacion) {
		return myComparacion.left.toCpp + " " + myComparacion.signo_op + " " + myComparacion.right.toCpp;
	}
	
	def toCpp(Igualdad myIgualdad) {
		return myIgualdad.left.toCpp + " " + myIgualdad.signo_op + " " + myIgualdad.right.toCpp;
	}
	
	def toCpp(Negativa myNegativa) {
		return "( - " + myNegativa.valor_operacion.toCpp + ")";
	}
	
	def toCpp(Negacion myNegacion) {
		return "!" + myNegacion.valor_operacion.toCpp;
	}
	
	def toCpp(Si mySi) '''
		if(«mySi.valor.toCpp»){
			«FOR sent:mySi.sentencias»
				«sent.toCpp»
			«ENDFOR»
			«IF mySi.devuelve != null» 
				«mySi.devuelve.toCpp»
			«ENDIF»	
		}
		«IF mySi.sino != null» 
			«mySi.sino.toCpp»
		«ENDIF»
	'''
	
	def toCpp(Caso myCaso) '''
		case «0»:
			«FOR sent:myCaso.sentencias»
				«sent.toCpp»
			«ENDFOR»
			«IF myCaso.devuelve != null» 
				«myCaso.devuelve.toCpp»
			«ENDIF»
		break;
	'''
	
	def toCpp(segun mySegun) '''
		switch(«mySegun.valor.toCpp»){
			«FOR cas:mySegun.caso»
				«cas.toCpp» 
			«ENDFOR»
			default:
				«FOR sent:mySegun.sentencias»
					«sent.toCpp»
				«ENDFOR»
				«IF mySegun.devuelve != null» 
				«mySegun.devuelve.toCpp»
				«ENDIF»
			break;
		}
	'''

	def toCpp(Devolver myDevuelve) '''
		return «myDevuelve.devuelve.toCpp»;
	'''

	def toCpp(Sino mySino) '''
		else{
			«FOR sent:mySino.sentencias»	
				«sent.toCpp»
			«ENDFOR»
			«IF mySino.devuelve != null» 
			«mySino.devuelve.toCpp»
			«ENDIF»	
		}
	'''

	def toCpp(mientras m) '''
		while(«m.valor.toCpp»){
			«FOR sent:m.sentencias»
				«sent.toCpp»
			«ENDFOR»
		}
	'''
	
	
	def toCpp(desde d) '''
		for(«d.asignacion.toCpp» «d.asignacion.valor_asignacion.toString» <= «d.valor.toCpp»; «d.asignacion.valor_asignacion.toString»++){
			«FOR sent:d.sentencias»
				«sent.toCpp»
			«ENDFOR»
		}
	'''

	def toCpp(repetir m) '''
		do{
			«FOR sent:m.sentencias»
				«sent.toCpp»
			«ENDFOR»
		}while(«m.valor.toCpp»);
	'''

}
